generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions", "fullTextSearch"]
  binaryTargets   = ["native", "debian-openssl-1.1.x"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  extensions = [uuid_ossp(map: "uuid-ossp")]
}

model User {
  id              Int        @id @default(autoincrement())
  email           String     @unique
  organizationId  Int?       
  organization    Reference? @relation("UserOrganization", fields: [organizationId], references: [id])
  createdMetadata Metadata[] @relation("MetadataCreatedBy")
  updatedMetadata Metadata[] @relation("MetadataUpdatedBy")
  ownedMetadata   Metadata[] @relation("MetadataOwnedBy")
  roles           Roles[]    @relation("UserRoles")

  @@map("user")
}

model Application {
  id                       Int                 @id @default(autoincrement())
  label                    String
  shortname                String
  logo                     String
  description              String
  url                      String
  uri                      String
  purposes                 String[]
  tags                     String[]
  lifecycleId              Int
  lifecycle                Lifecycle           @relation("LifecycleApplications", fields: [lifecycleId], references: [id])
  metadataId               Int
  metadata                 Metadata            @relation("ApplicationMetadata", fields: [metadataId], references: [id])
  parentId                 Int? 
  parent                   Application?        @relation("ApplicationParent", fields: [parentId], references: [id])
  children                 Application[]       @relation("ApplicationParent")
  roles                    Roles[]             @relation("ApplicationRoles")
  externalReferences       Reference[]         @relation("ApplicationExternalReferences")
  compliances              Compliance[]        @relation("ApplicationCompliances")
  environments             Environment[]       @relation("ApplicationEnvironments")

  @@map("application")
}

model Roles {
  id              Int        @id @default(autoincrement())
  type            String
  userId          Int
  user            User       @relation("UserRoles", fields: [userId], references: [id])
  organizationId  Int?      
  organization    Reference? @relation("RolesOrganization", fields: [organizationId], references: [id])
  applicationId   Int?
  application     Application? @relation("ApplicationRoles", fields: [applicationId], references: [id])

  @@map("roles")
}

model Reference {
  id              Int                 @id @default(autoincrement())
  repositoryId    Int                 
  repository      ReferenceRepository @relation("ReferenceRepositoryReferences", fields: [repositoryId], references: [id])
  value           String
  label           String
  shortName       String
  lastUpdateDate  DateTime
  metadataId      Int
  metadata        Metadata            @relation("ReferenceMetadata", fields: [metadataId], references: [id])
  users           User[]              @relation("UserOrganization")
  roles           Roles[]             @relation("RolesOrganization")
  applicationId   Int?
  application     Application?        @relation("ApplicationExternalReferences", fields: [applicationId], references: [id])

  @@map("reference")
}

model ReferenceRepository {
  id             Int                      @id @default(autoincrement())
  type           ReferenceRepositoryType
  uri            String
  valueType      ReferenceRepositoryValueType
  metadataId     Int
  metadata       Metadata                 @relation("ReferenceRepositoryMetadata", fields: [metadataId], references: [id])
  references     Reference[]              @relation("ReferenceRepositoryReferences")

  @@map("reference_repository")
}

model Compliance {
  id              Int                 @id @default(autoincrement())
  type            ComplianceType
  name            String
  status          ComplianceStatus
  validityStart   DateTime?
  validityEnd     DateTime?
  scoreValue      String?
  scoreUnit       String?
  notes           String?
  metadataId      Int?
  metadata        Metadata?            @relation("ComplianceMetadata", fields: [metadataId], references: [id])
  applicationId   Int?
  application     Application?        @relation("ApplicationCompliances", fields: [applicationId], references: [id])

  @@map("compliance")
}

model Environment {
  id             Int         @id @default(autoincrement())
  applicationId  Int
  application    Application @relation("ApplicationEnvironments", fields: [applicationId], references: [id])

  @@map("environment")
}

model Lifecycle {
  id                          Int              @id @default(autoincrement())
  status                      LifecycleStatus
  firstProductionDate         DateTime
  plannedDecommissioningDate  DateTime?
  metadataId                  Int
  metadata                    Metadata          @relation("LifecycleMetadata", fields: [metadataId], references: [id])
  applications                Application[]     @relation("LifecycleApplications")

  @@map("lifecycle")
}

model Metadata {
  id            Int          @id @default(autoincrement())
  DateTime      DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
  createdById   Int
  createdBy     User         @relation("MetadataCreatedBy", fields: [createdById], references: [id])
  updatedById   Int
  updatedBy     User         @relation("MetadataUpdatedBy", fields: [updatedById], references: [id])
  ownerId       Int?
  owner         User?        @relation("MetadataOwnedBy", fields: [ownerId], references: [id])
  references    Reference[]  @relation("ReferenceMetadata")
  referencesRepository ReferenceRepository[] @relation("ReferenceRepositoryMetadata")
  applications  Application[] @relation("ApplicationMetadata") 
  lifecycle     Lifecycle[]   @relation("LifecycleMetadata")
  compliance    Compliance[] @relation("ComplianceMetadata")

  @@map("metadata")
}

enum LifecycleStatus {
  under_construction
  in_production
  decommissioned
}

enum ComplianceType {
  regulation
  standard
  policy
  contractual
  security
  privacy
}

enum ComplianceStatus {
  compliant
  non_compliant
  partially_compliant
  not_concerned
}

enum ReferenceRepositoryType {
  organization
  application
  regulation
  financial
  population
}

enum ReferenceRepositoryValueType {
  url
  uri
  identifier
  name
}
